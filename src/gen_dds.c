#include "gen_dds.h"
#include "settings.h"
#include "stm32f103x6.h"


// dds генераторы для TX, компенсации разбаланса и звука

// ширина импульсов для косинуса, 256 уровней
static const uint8_t g_cos_table[1024] = {
128, 129, 130, 130, 131, 132, 133, 133,
134, 135, 136, 137, 137, 138, 139, 140,
140, 141, 142, 143, 144, 144, 145, 146,
147, 147, 148, 149, 150, 151, 151, 152,
153, 154, 154, 155, 156, 157, 157, 158,
159, 160, 160, 161, 162, 163, 164, 164,
165, 166, 167, 167, 168, 169, 169, 170,
171, 172, 172, 173, 174, 175, 175, 176,
177, 178, 178, 179, 180, 180, 181, 182,
183, 183, 184, 185, 185, 186, 187, 187,
188, 189, 189, 190, 191, 192, 192, 193,
194, 194, 195, 196, 196, 197, 198, 198,
199, 199, 200, 201, 201, 202, 203, 203,
204, 205, 205, 206, 206, 207, 208, 208,
209, 209, 210, 211, 211, 212, 212, 213,
214, 214, 215, 215, 216, 216, 217, 218,
218, 219, 219, 220, 220, 221, 221, 222,
222, 223, 224, 224, 225, 225, 226, 226,
227, 227, 228, 228, 229, 229, 229, 230,
230, 231, 231, 232, 232, 233, 233, 234,
234, 234, 235, 235, 236, 236, 237, 237,
237, 238, 238, 239, 239, 239, 240, 240,
240, 241, 241, 242, 242, 242, 243, 243,
243, 244, 244, 244, 245, 245, 245, 245,
246, 246, 246, 247, 247, 247, 248, 248,
248, 248, 249, 249, 249, 249, 250, 250,
250, 250, 250, 251, 251, 251, 251, 251,
252, 252, 252, 252, 252, 253, 253, 253,
253, 253, 253, 253, 254, 254, 254, 254,
254, 254, 254, 254, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 255, 255, 255,
255, 255, 255, 255, 255, 254, 254, 254,
254, 254, 254, 254, 254, 253, 253, 253,
253, 253, 253, 253, 252, 252, 252, 252,
252, 251, 251, 251, 251, 251, 250, 250,
250, 250, 250, 249, 249, 249, 249, 248,
248, 248, 248, 247, 247, 247, 246, 246,
246, 245, 245, 245, 245, 244, 244, 244,
243, 243, 243, 242, 242, 242, 241, 241,
240, 240, 240, 239, 239, 239, 238, 238,
237, 237, 237, 236, 236, 235, 235, 234,
234, 234, 233, 233, 232, 232, 231, 231,
230, 230, 229, 229, 229, 228, 228, 227,
227, 226, 226, 225, 225, 224, 224, 223,
222, 222, 221, 221, 220, 220, 219, 219,
218, 218, 217, 216, 216, 215, 215, 214,
214, 213, 212, 212, 211, 211, 210, 209,
209, 208, 208, 207, 206, 206, 205, 205,
204, 203, 203, 202, 201, 201, 200, 199,
199, 198, 198, 197, 196, 196, 195, 194,
194, 193, 192, 192, 191, 190, 189, 189,
188, 187, 187, 186, 185, 185, 184, 183,
183, 182, 181, 180, 180, 179, 178, 178,
177, 176, 175, 175, 174, 173, 172, 172,
171, 170, 169, 169, 168, 167, 166, 166,
165, 164, 164, 163, 162, 161, 160, 160,
159, 158, 157, 157, 156, 155, 154, 154,
153, 152, 151, 151, 150, 149, 148, 147,
147, 146, 145, 144, 144, 143, 142, 141,
140, 140, 139, 138, 137, 137, 136, 135,
134, 133, 133, 132, 131, 130, 130, 129,
128, 127, 126, 126, 125, 124, 123, 123,
122, 121, 120, 119, 119, 118, 117, 116,
115, 115, 114, 113, 112, 112, 111, 110,
109, 109, 108, 107, 106, 105, 105, 104,
103, 102, 102, 101, 100, 99, 99, 98,
97, 96, 95, 95, 94, 93, 92, 92,
91, 90, 89, 89, 88, 87, 87, 86,
85, 84, 84, 83, 82, 81, 81, 80,
79, 78, 78, 77, 76, 76, 75, 74,
73, 73, 72, 71, 71, 70, 69, 69,
68, 67, 67, 66, 65, 64, 64, 63,
62, 62, 61, 60, 60, 59, 58, 58,
57, 57, 56, 55, 55, 54, 53, 53,
52, 51, 51, 50, 50, 49, 48, 48,
47, 46, 46, 45, 45, 44, 44, 43,
42, 42, 41, 41, 40, 40, 39, 38,
38, 37, 37, 36, 36, 35, 35, 34,
34, 33, 32, 32, 31, 31, 30, 30,
29, 29, 28, 28, 27, 27, 27, 26,
26, 25, 25, 24, 24, 23, 23, 22,
22, 22, 21, 21, 20, 20, 19, 19,
19, 18, 18, 17, 17, 17, 16, 16,
16, 15, 15, 14, 14, 14, 13, 13,
13, 12, 12, 12, 11, 11, 11, 11,
10, 10, 10, 9, 9, 9, 8, 8,
8, 8, 7, 7, 7, 7, 6, 6,
6, 6, 6, 5, 5, 5, 5, 5,
4, 4, 4, 4, 4, 3, 3, 3,
3, 3, 3, 3, 2, 2, 2, 2,
2, 2, 2, 2, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 1, 1, 1,
1, 1, 1, 1, 1, 2, 2, 2,
2, 2, 2, 2, 2, 3, 3, 3,
3, 3, 3, 3, 4, 4, 4, 4,
4, 5, 5, 5, 5, 5, 6, 6,
6, 6, 6, 7, 7, 7, 7, 8,
8, 8, 8, 9, 9, 9, 10, 10,
10, 11, 11, 11, 11, 12, 12, 12,
13, 13, 13, 14, 14, 14, 15, 15,
16, 16, 16, 17, 17, 17, 18, 18,
19, 19, 19, 20, 20, 21, 21, 22,
22, 22, 23, 23, 24, 24, 25, 25,
26, 26, 27, 27, 27, 28, 28, 29,
29, 30, 30, 31, 31, 32, 32, 33,
34, 34, 35, 35, 36, 36, 37, 37,
38, 38, 39, 40, 40, 41, 41, 42,
42, 43, 44, 44, 45, 45, 46, 47,
47, 48, 48, 49, 50, 50, 51, 51,
52, 53, 53, 54, 55, 55, 56, 57,
57, 58, 58, 59, 60, 60, 61, 62,
62, 63, 64, 64, 65, 66, 67, 67,
68, 69, 69, 70, 71, 71, 72, 73,
74, 74, 75, 76, 76, 77, 78, 79,
79, 80, 81, 81, 82, 83, 84, 84,
85, 86, 87, 87, 88, 89, 90, 90,
91, 92, 93, 93, 94, 95, 96, 96,
97, 98, 99, 99, 100, 101, 102, 102,
103, 104, 105, 105, 106, 107, 108, 109,
109, 110, 111, 112, 112, 113, 114, 115,
116, 116, 117, 118, 119, 119, 120, 121,
122, 123, 123, 124, 125, 126, 126, 127
};


// текущая фаза генератора TX
static uint32_t g_phase_tx = 0;
// текущая фаза генератора компенсации разбаланса
static volatile uint32_t g_phase_comp = 0;
// текущая фаза генератора звука
static uint32_t g_phase_sound = 0;
// уровень выходного сигнала TX [0..256]
static volatile uint32_t g_level_tx = 0;
// уровень выходного сигнала компенсации разбаланса [0..256]
static volatile uint32_t g_level_comp = 0;
// уровень громкости звука [0...256]
static volatile uint32_t g_level_sound = 0;
// частота (сдвиг фазы генератора) TX и сигнала компенсации
static uint32_t g_gen_freq = 0;
// частота (сдвиг фазы генератора) звука
static uint32_t g_sound_freq = 0;


uint32_t get_tx_phase() {
  return g_phase_tx;
}


uint32_t get_tx_freq() {
  return g_gen_freq;
}


void set_sound_freq_by_angle( uint32_t a_angle ) {
  g_sound_freq = 512u + (uint32_t)( ((((uint64_t)a_angle) * 10) << 32) / BASE_PWM_FREQ );
}


uint32_t get_tx_level() {
  return g_level_tx;
}


uint32_t get_cm_level() {
  return g_level_comp;
}


void set_tx_level( uint32_t a_level ) {
  if ( a_level > MAX_TX_LEVEL ) {
    a_level = MAX_TX_LEVEL;
  } else {
    if ( a_level < MIN_TX_LEVEL ) {
      a_level = MIN_TX_LEVEL;
    }
  }
  g_level_tx = a_level;
}


void set_cm_level( uint32_t a_level ) {
  if ( a_level > MAX_TX_LEVEL ) {
    a_level = MAX_TX_LEVEL;
  } else {
    if ( a_level < MIN_TX_LEVEL ) {
      a_level = MIN_TX_LEVEL;
    }
  }
  g_level_comp = a_level;
}


// установить громкость звука
void set_sound_volume( uint32_t a_volume ) {
  if ( a_volume > MAX_SOUND_VOLUME ) {
    a_volume = MAX_SOUND_VOLUME;
  } else {
    if ( a_volume < MIN_SOUND_VOLUME ) {
      a_volume = MIN_SOUND_VOLUME;
    }
  }
  g_level_sound = a_volume;
}


// изменить текущую фазу сигнала компенсации
void set_cm_phase( uint32_t a_phase_diff ) {
  // запоминаем текущую фазу генератора
  uint32_t v_phase = g_phase_comp;
  // ждём изменения фазы генератора (сгенерирован очередной отсчёт)
  while ( v_phase == g_phase_comp ) {}
  // меняем фазу генератора между отсчётами
  g_phase_comp += a_phase_diff;
}


// настройка таймера-1
// канал 1 - генерация "синуса" для TX
// канал 2 - генерация "синуса" для сигнала компенсации
// канал 3 - генерация "пинков" для АЦП (cобытие сравнения 2 раза за период)
// канал 4 - генерация "синуса" для звука
void gen_dds_init() {
  // настройки генераторов из профиля
  settings_t * v_profile = settings_get_current_profile();
  g_level_tx = v_profile->level_tx; // по базовой схеме ~60 мА
  g_level_comp = v_profile->level_comp;
  g_level_sound = v_profile->level_sound;
  g_gen_freq = v_profile->gen_freq;
  g_phase_comp = v_profile->phase_comp_start;
  // включаем выводы каналов CH1/PA8, CH2/PA9, CH3/PA11 таймера-1
  // alternate push-pull 2MHz
  GPIOA->CRH = (GPIOA->CRH & ~( GPIO_CRH_MODE8_Msk | GPIO_CRH_CNF8_Msk
                              | GPIO_CRH_MODE9_Msk | GPIO_CRH_CNF9_Msk
                              | GPIO_CRH_MODE10_Msk | GPIO_CRH_CNF10_Msk
                              ))
               | GPIO_CRH_MODE8_1  | GPIO_CRH_CNF8_1
               | GPIO_CRH_MODE9_1  | GPIO_CRH_CNF9_1
               | GPIO_CRH_MODE10_1 | GPIO_CRH_CNF10_1
               ;
  // настраиваем таймер-1
  // тактируется от APB2 без делителя (72МГц), двунаправленный счётчик, APR=256, период 512 тактов
  // ШИМ 8 битов (частота 72000000 / 512 = 140625). Update Event один раз за период, т.е. RCR=1
  // Output Trigger по включению таймера для одновременного запуска TIM3
  TIM1->PSC = 0; // без делителя
  TIM1->ARR = 256; // докуда считать
  TIM1->RCR = 1; // "делитель" частоты Update Event
  TIM1->CNT = 0; // на всяк случ сброс счётчика
  TIM1->CCR1 = g_cos_table[0]; // TX начинаем с нулевой фазы
  // сигнал компенсации по фазе от g_phase_comp, может быть прочитано из профиля и != 0
  // 1024 отсчёта - период "синусоиды", 2^32 - период фазы генератора (DDS)
  TIM1->CCR2 = g_cos_table[g_phase_comp >> 22];
  TIM1->CCR3 = g_cos_table[0]; // звук, с нулевой фазы, тут пофик
  // режимы сравнения для трёх каналов
  TIM1->CCMR1 = TIM_CCMR1_OC1M_1 | TIM_CCMR1_OC1M_2 | TIM_CCMR1_OC1PE
              | TIM_CCMR1_OC2M_1 | TIM_CCMR1_OC2M_2 | TIM_CCMR1_OC2PE
              ;
  TIM1->CCMR2 = TIM_CCMR2_OC3M_1 | TIM_CCMR2_OC3M_2 | TIM_CCMR2_OC3PE
              ;
  TIM1->CCER = TIM_CCER_CC1E
             | TIM_CCER_CC2E
             | TIM_CCER_CC3E
             ;
  TIM1->BDTR = TIM_BDTR_MOE
             | TIM_BDTR_OSSR
             ;
  TIM1->CR2 = TIM_CR2_MMS_0; // запуск таймера - событие TRGO
  TIM1->CR1 = TIM_CR1_CMS_0 | TIM_CR1_CMS_1
            | TIM_CR1_URS
            ;
  TIM1->SR = 0;
  TIM1->DIER = TIM_DIER_UIE;
  // настраиваем таймер-3 для пинания АЦП, тактирование 36 МГц (APB1 без делителя)
  // счёт вверх до 127 (0..127, 128 тактов), запуск синхронно со стартом TIM1
  TIM3->PSC = 0;
  TIM3->CR1 = TIM_CR1_URS;
  TIM3->CR2 = TIM_CR2_MMS_1;
  TIM3->ARR = 127;
  TIM3->CNT = 0;
  TIM3->SMCR = TIM_SMCR_SMS_1
             | TIM_SMCR_SMS_2
             ;
  // запускаем TIM1 и TIM3
  TIM1->CR1 |= TIM_CR1_CEN;
  __NVIC_EnableIRQ( TIM1_UP_IRQn );
  // генерируем Update Event, чтобы в "теневые" регистры попали текущие значения
  // а в буферные регистры легли новые значения (для следующего периода)
  // TIM1->EGR = TIM_EGR_UG;
}


void gen_dds_shutdown() {
  // отключаем прерывание от таймера
  __NVIC_DisableIRQ( TIM1_UP_IRQn );
}


// событие update таймера-1, обновляем регистры сравнения
// эти значения перепишутся в "теневые" регистры при следующем Update Event
void ih_TIM1_UP_IRQ() {
  // подвинем фазу
  g_phase_tx += g_gen_freq;
  // значение косинуса берём из таблицы
  TIM1->CCR1 = (g_cos_table[g_phase_tx >> 22] * g_level_tx) >> 12;
  // подвинем фазу
  g_phase_comp += g_gen_freq;
  // значение косинуса из таблицы
  TIM1->CCR2 = (g_cos_table[g_phase_comp >> 22] * g_level_comp) >> 12;
  // подвинем фазу
  g_phase_sound += g_sound_freq;
  // значение косинуса из таблицы
  TIM1->CCR3 = (g_cos_table[g_phase_sound >> 22] * g_level_sound) >> 12;
  // сбрасываем флаги прерывания
  TIM1->SR = 0;
}
